---
title: "Data Wrangling Final Project"
author: "Brianna Eskin"
date: "4/14/2020"
output: pdf_document
---
```{r packages, echo=FALSE, warning=FALSE, include=FALSE}
source("C:\\Users\\Brianna\\Documents\\R\\597\\Final Project\\DataWranglingProjectSpring2020\\functions.r")
options(timeout = 400000)
options(scipen = 999999)
```

## Introduction

The game show Jeopardy!, created by Merv Griffin and hosted by Art Fleming, first premiered on March 30, 1964 on NBC. After a few different syndicated versions, the show as it is known today, hosted by Alex Trebek, premiered on September 10, 1984. Since its premiere, the current version of Jeopardy!, which is in its 36th season, has aired over 8000 episodes, won over 30 Daytime Emmy awards, and is often regarded as one of the greatest television shows in American television history.

Despite a few minor tweaks over time, the gameplay of Jeopardy! has remained largely the same. There are three rounds in a standard game of Jeopardy!, the Jeopardy round, Double Jeopardy, and Final Jeopardy. In the first two rounds, contestants select clues from six predetermined categories valued by difficulty. These clues are presented as "answers" and the responses from the contestants are given in the form of a question. For example, the clue might say "This is the official state university of New Jersey". The first contestant to buzz in would give the response of "What is Rutgers University?". If the contestant responds correctly, he/she is awarded money based on the value of the clue. If the contestant responds incorrectly, he/she loses money based on the value of the clue. Under some clues- one in the Jeopardy round and two in the Double Jeopardy round- there is a Daily Double. When the Daily Double is found, the contestant, who has the clue all to themselves, can wager any or all of the current money they have available, and gain or lose that amount depending on their response to the clue. After the first two rounds, there is a Final Jeopardy round. In Final Jeopardy, the contestants are given the category and based on factors including their confidence in the category and the scores of themselves/their opponents, wager any or all of their winnings, similar to a Daily Double. Then the clue is revealed and the contestants write their answers at their podium. Their reponses and wagers are then revealed and after this round, whoever has the most money is declared the victor and comes back the next day as the returning Champion, getting to keep all of the money they earned.

For my project, I will be wrangling data pertaining to the all time highest Jeopardy! winners, as listed on https://www.jeopardy.com/contestant-zone/hall-of-fame. As of April 14, 2020 these contestants are:
  
1. Brad Rutter
2. Ken Jennings
3. James Holzhauer
4. David Madden
5. Larissa Kelly
6. Matt Jackson
7. Jason Zuffranieri
8. Roger Craig
9. Colby Burnett
10. Julia Collins

For each of the all time highest Jeopardy!, I will be analyzing their overall winnings, as well as their individual regular season and tournament gameplays. I will be looking at their distribution of money earned in regular season play versus the various tournaments Jeopardy! has held over the years. I will also be analyzing individual game scores and statistics.

I was interested in data pertaining to Jeopardy! because of the personal connection Jeopardy! has in my life. Jeopardy! is my favorite television show, and one of the few television programs I watch on a consistent basis. I started wathcing afternoon reruns with my grandmother while she babysat us during school vacations, but given that I was in elementary school at the time, I couldn't keep up most of the time. After she passed away in 2007, I fell off of watching for a bit, but got back into it during high school. My dad would start watching with me, not necessarily because he was also into it, but because I would take up the good television in our living room and he didn't feel like moving. Over time, both of our investments in the game began to grow and for years, we never missed a game, even while he was spending nights in the hospital due to complications from cancer, until he passed away in 2018. Jeopardy! has left such a huge mark on my life, and because there are so many aspects of Jeopardy! to analyze, this made for good data to wrangle.   

## Data Sources

For my project, I will be scraping data from the J-Archive (https://j-archive.com/), which is a fan run archive of most of the games from the Alex Trebek era of Jeopardy!. The site is broken down to different pages for each individual game. To find the different games each contestant played in, I will scrape from their different player profile pages, 16 pages in total, which were found by manually checking the j-archive, as one player can have multiple player pages. An example page for Jason Zuffranieri is http://www.j-archive.com/showplayer.php?player_id=12824. On this page, I will be pulling the various games each contestant played in and scraping data from that specific game's web page. An example is based on Jason's player page, I know he played in Game #8046, which is also the 36th season permiere. So I will be scraping data from that page, http://www.j-archive.com/showgame.php?game_id=6410. For that specific game, I will then be scraping data from the score breakdown page, which for the example game #8046 is http://www.j-archive.com/showscores.php?game_id=6410. I will be repeating this process for each game a contestant has played in. Using Jason as an example, he has played in 20 regular season games of Jeopardy!, so I will be scraping 20 game level sites and 20 score breakdown sites.
  
<Should I potentially add screenshots here?>

## Data Scraping

The first thing I did to start scraping data was I created a static data frame called contestants, whose structure is as below:

```{r contestants, echo = FALSE}
contestants <- data.frame(ColumnName = c("Contestants", "playerIds", "AllStarsTeam"), Definition = c("Full name of a top 10 all-time winning contestant on Jeopardy!", "Player ID as extracted from the j-archive", "The team a contestant played on during the All-Star tournament in 2019- marked as No Team if not a participant"), Type = c("character()", "integer()", "character()"))
contestants
contestants <- data.frame(
  Contestants = c("Brad Rutter", "Brad Rutter", "Brad Rutter", "Ken Jennings", "Ken Jennings", "James Holzhauer", "David Madden", "Larissa Kelly", "Larissa Kelly", "Matt Jackson", "Jason Zuffranieri", "Roger Craig", "Roger Craig", "Colby Burnett", "Colby Burnett", "Julia Collins"), playerIds = c(278, 622, 12536, 661, 12547, 12983, 1963, 4956, 12539, 10266, 12824, 6976, 12550, 8057, 12537, 9517), AllStarsTeam = c("Team Brad", "Team Brad", "Team Brad", "Team Ken", "Team Ken", "No Team", "Team Brad", "Team Brad", "Team Brad", "Team Ken", "No Team", "Team Austin", "Team Austin", "Team Colby", "Team Colby", "Team Julia"), stringsAsFactors = FALSE
)
contestant_names <- c("Brad Rutter", "Ken Jennings", "James Holzhauer", "David Madden", "Larissa Kelly", "Matt Jackson", "Jason Zuffranieri", "Roger Craig", "Colby Burnett", "Julia Collins")
```

Next, I created my main data frame, which contains a record of each game a contestant has played of Jeopardy! and some relevant stats for each game. The structure is as follows:

```{r mainTableInit, echo = FALSE, warning = FALSE}
game_level_df <- data.frame(Column = c("Contestant", "GameIdForUrl", "GameId", "Date", "FinalScore", "Outcome", "GameFormat", "TournamentName", "CoryatScore"), Definition = c("Full Name of Contestant", "The Game ID that will be passed into the URL for scraping", "The official Jeopardy! Game ID", "The date the episode premiered", "The contestants final score (not necessarily winnings)", "Contestant's placement in that game. Also notes if game was an accumulated score, such as a Tournament Final", "Was the game part of a tournament or the regular season", "Tournament name, or regular season if not a tournament", "Score unadjusted for Daily Doubles and Final Jeopardy"), Type = c("character()", "integer()", "integer()", "character()", "integer()", "character()", "character()", "character()", "integer()"))
game_level_df
game_level_df <- data.frame(Contestant = character(),
                            GameIdForUrl = integer(),
                            GameId = integer(),
                            Date = character(),
                            FinalScore = integer(),
                            Outcome = character(),
                            GameFormat = character(), 
                            TournamentName = character(),
                            CoryatScore = integer(),
                            stringsAsFactors = FALSE
)
```

To fill this table, I had to scrape the game level and score sites for every game played by these Jeopardy! contestants. First, I had to identify every game a contestant played in. To do that, I created a function, getGameIdsForUrl, which inputs a playerId from the contestant table and scrapes the player site for the playerId. The output is then a list of gameIds that will eventually be passed into URLs. In order to do this, I scraped each site using the read_html() function and html_nodes(), using "a" HTML tag, since I was interested in the hyperlinks on the page. I then mapped the returned xml nodeset as a dataframe. For the next step, I filtered out unneccessary hyperlinks by filtering links which had "game_id" as part of the link. Once my list was limited to only hyperlinks that pointed to show games, I was able to extract the gameId in the URL with the regular expression "\\d+". The function then outputted this list of Ids.
  
As a next step, I iterated through this list of gameIds and passed each one into a new function, getRowForGameLevelTable. This function requires the contestant name, the gameId that will be passed into a URL, and the All-Star team the contestant played on during the All-Star games tournament in 2019. In this function, I scraped two different sites, the game level site and the score site, using the gameId I extracted earlier. Using these two sites, I was able to extract the remiaining information required for my table. I've provided a brief explanation as to how I pulled the remaining attributes required below:

1. GameId and Date: These attributes were pulled from the game level site, reading the "h1" node and extracting based on regular expressions. An example h1 is "Show #8059 - Thursday, September 26, 2019". For the GameId, I used the expression "(?<=\\#)\\d+", to pull all digits after the #. For the Date, I used the expression "(?<=-\\s).*(?=\\<)" to pull everything after the - , but stopped if I saw a "<", to avoid pulling the end of the tag as well.
2. FinalScore: To find the finalScore, I read all of the tables using html_table() from the scores sites, taking the 4th table. After some cleaning to account for cases where the game was part of a multi-day contest where the winner was decided by the sum of scores over multiple days- such as tournament finals, I ended up with a table that had the contestants, scores, and outcomes. I filtered on the contestant I was interested in and pulled the final score, using the regular expression "\\d+,\\d+|\\d+" to take all of the digits. I then removed the commas and converted into an integer.
3. Outcome: Using the table I created to extract the final score, I pulled the Outcome using the raw outcome column without any transformations.
4. GameFormat: From the game level site, I extracted nodes called "#game_comments", which normally inlucdes information such as the contestants playing in that game, any special highlights, and the tournament name, if applicable. To find whether or not a game was part of the regular season or tournament, I read the first of these "#game_comments" nodes, and set the format to Tournament if the regular expression "Tournament|Masters|Decade|Star" was found. Another possible option for GameFormat is Exhibition, which refers to the IBM Challenge in 2011 in which Brad Rutter and Ken Jennings played Jeopardy against IBM Watson. I set the GameFormat to Exhibition if I matched the expression "IBM". Otherwise, the format was set to Regular Season.
5. TournamentName: To pull the tournament name, I used a series of ifelse functions checking various regular expressions to match the different tournament names that have occurred over the years. If there were no matches, the TournamentName was set to Regular Season.
6. Coryat Score: I followed the exact same steps as what were used to pull the final score, the only difference is that I pulled the last table from the scores site, instead of always pulling the 4th table.

```{r mainTableScraping, echo=FALSE, warning=FALSE}
for (row in 1:nrow(contestants)) {
  contestant <- contestants[row, 1]
  player_id <- contestants[row, 2]
  allStarTeam <- contestants[row, 3]
  gameIdsForUrl <- getGameIdsForUrl(player_id)
  for (row in 1:nrow(gameIdsForUrl)) {
    gameIdForUrl <- gameIdsForUrl[row, 1]
    rowForGameLevelTable <- getRowForGameLevelTable(contestant, gameIdForUrl, allStarTeam)
    if(rowForGameLevelTable != "Don't include"){
      game_level_df <- rbind(game_level_df, rowForGameLevelTable)
    }
  }
}
game_level_df <- game_level_df %>%
  distinct()
game_level_df$Outcome <- as.character(game_level_df$Outcome)
```

Below is a sample output for Jeopardy contestant Roger Craig.

```{r dataScrapingOutput, echo = FALSE}
game_level_df %>%
  filter(Contestant == "Roger Craig") %>%
  arrange(desc(GameId)) %>%
  head()
```

## All-Time Winnings
The first piece of data I am planning to analyze is a breakdown of how much money each contestant has earned over different tournaments versus regular season play. I will store the tournament winnings in a new table, tournament_winnings_df, whose structure is:

```{r AllTimeWinningsSetup, echo = FALSE}
tournament_winnings_df <- data.frame(
  Columns = c("Contestant", "TournamentName", "Outcome", "Winnings"),
  Definition = c("Contestant Name", "Tournament Name", "Contestant's performance in final game they competed", "How much money was won - not necessarily their final score"),
  Type = c("character()", "character()", "character()", "integer()")
)
tournament_winnings_df
tournament_winnings_df <- data.frame(
  Contestant = character(),
  TournamentName = character(),
  Outcome = character(),
  Winnings = integer(),
  stringsAsFactors = FALSE
)
```

To extract the winnings for each tournament a contestant played in, I pulled the unique Contestant/TournamentName pair from my main game level dataframe. Then, filtering through that dataframe, I went back into my main game level dataframe and pulled the last game a contestant played in that specific tournament based on the max gameId. I then checked if the game was an Accumulated Total. If it was, I had to scrape a new table from the scores site for that particular game, which was the table that reflected the accumulated scores over the multiple games in that round of a tournament (usually a finals). From here, I was able to pull the tournament outcome in a similar fashion to how that information was pulled for the main game level dataframe. If the game wasn't an accumulated total, all I needed to do was pull the outcome from my main game level dataframe. I was then able to pull winnings from the Outcome using the regular expression "(?<=:\\s)[\\$\\d+,]+".

```{r AllTimeWinningsScrapingTournament, echo=FALSE}
game_level_df_tournament <- game_level_df %>%
  filter(TournamentName != "Regular Season") %>%
  select(Contestant, TournamentName) %>%
  distinct()
for (row in 1:nrow(game_level_df_tournament)) {
  contestant <- game_level_df_tournament[row, 1]
  tournamentName <- game_level_df_tournament[row, 2]
  rowForTournamentWinningTable <- getRowForTournamentWinningsTable(contestant, tournamentName)
  tournament_winnings_df <- rbind(tournament_winnings_df, rowForTournamentWinningTable)
}
game_level_df_regular_season <- game_level_df %>%
  filter(TournamentName == "Regular Season") %>%
  select(Contestant, GameId, TournamentName, FinalScore, Outcome)
for (contestant in contestant_names) {
    if(contestant != "Brad Rutter") {
    game_level_df_regular_season_filtered <- game_level_df_regular_season %>%
      filter(Contestant == contestant) %>%
      filter(GameId == max(GameId))
    gameId <- game_level_df_regular_season_filtered$GameId
    winnings <- str_extract(game_level_df_regular_season_filtered$Outcome,"(?<=:\\s).*") %>%
      str_replace_all("\\$|,", "") %>%
      as.numeric()
    game_level_df_regular_season[game_level_df_regular_season$GameId == gameId, "FinalScore"] <- winnings
  }
}
winnings_df <- game_level_df_regular_season %>%
  select(Contestant, TournamentName, Outcome, FinalScore)
colnames(winnings_df)[4] <- "Winnings"
winnings_df <- winnings_df %>%
  rbind(tournament_winnings_df) %>%
  mutate(Format = ifelse(TournamentName == "Regular Season", "Regular Season", "Tournament"))
```

Next, I needed to clean the data pertaining to the regular season winnings. For the most part, the winnings for a particular game could be pulled from the FinalScore column in my main game level dataframe. The exception to this is when a contestant loses. In Jeopardy! regular season play, third place contestants leave with \$1000 and second place contestants leave with \$2000. In addition, prior to Season 20, which premiered September 8, 2003, there was a 5 game limit for Champions, meaning if they went 5 consecutive games without losing, they were "retired" and three new contestants played the next game. One of the contestants, Brad Rutter, played his original Jeopardy run under this rule, so when pulling the winnings for Brad, I was always able to use the FinalScore, since his winnings in regular season play always matched what he earned. For everyone else, I had to pull their final regular season game using the max gameId, since their last game would have been the game they lost. I then pulled the winnings from the Outcome in a similar fashion to how I did for the tournament winnings, and adjusted the FinalScore for that game only.

```{r AllTimeWinningsScrapingRegularSeason, echo=FALSE}
game_level_df_regular_season <- game_level_df %>%
  filter(TournamentName == "Regular Season") %>%
  select(Contestant, GameId, TournamentName, FinalScore, Outcome)
for (contestant in contestant_names) {
    if(contestant != "Brad Rutter") {
    game_level_df_regular_season_filtered <- game_level_df_regular_season %>%
      filter(Contestant == contestant) %>%
      filter(GameId == max(GameId))
    gameId <- game_level_df_regular_season_filtered$GameId
    winnings <- str_extract(game_level_df_regular_season_filtered$Outcome,"(?<=:\\s).*") %>%
      str_replace_all("\\$|,", "") %>%
      as.numeric()
    game_level_df_regular_season[game_level_df_regular_season$GameId == gameId, "FinalScore"] <- winnings
  }
}
```

Once I had two separate tables, one for the tournament winnings and one for regular season winnings, I merged the two together using rbind.

```{r AllTimeWinningsMerge, echo=FALSE}
winnings_df <- game_level_df_regular_season %>%
  select(Contestant, TournamentName, Outcome, FinalScore)
colnames(winnings_df)[4] <- "Winnings"
winnings_df <- winnings_df %>%
  rbind(tournament_winnings_df) %>%
  mutate(Format = ifelse(TournamentName == "Regular Season", "Regular Season", "Tournament"))
```

Now that I have one table which stores the winnings for each Jeopardy! contestant, I was able to plot a graph of winnings for each Jeopardy contestant. I chose to use a bar graph where the fill was the Format (Regular Season or Tournament).

```{r winningsPlots, echo = FALSE}
winnings_df %>%
  select(Contestant, Format, Winnings) %>%
  group_by(Contestant, Format) %>%
  summarize(CummulativeEarnings = sum(Winnings)) %>%
  mutate(CummulativeEarnings = ifelse(is.na(CummulativeEarnings), 0, CummulativeEarnings)) %>%
  ggplot() +
  geom_bar(mapping = aes(x = Contestant, y = CummulativeEarnings, fill = Format), stat ="identity") +
  ggtitle("Earnings of Top Ten All-Time Winning Jeopardy Contestants") +
  theme(axis.text.x = element_text(angle = 90))
```



```{r winningsPlot2, echo=FALSE}
winnings_df %>%
  select(Contestant, TournamentName, Winnings) %>%
  group_by(Contestant, TournamentName) %>%
  summarize(CummulativeEarnings = sum(Winnings)) %>%
  mutate(CummulativeEarnings = ifelse(is.na(CummulativeEarnings), 0, CummulativeEarnings)) %>%
  ggplot() +
  geom_bar(mapping = aes(x = Contestant, y = CummulativeEarnings, fill = TournamentName), stat ="identity") +
  ggtitle("Earnings of Top Ten All-Time Winning Jeopardy Contestants by Tournament") +
  theme(axis.text.x = element_text(angle = 90))
```

## Scores Plotting

<Talk about how we will plot scores (not winnings) over course of regular season>

```{r scorePlotting, echo=FALSE}
game_scores_df_regular_season <- game_level_df %>%
  filter(TournamentName == "Regular Season") %>%
  select(Contestant, GameId, FinalScore) %>%
  group_by(Contestant) %>%
  mutate(GamePlayed = min_rank(GameId))
ggplot(data = game_scores_df_regular_season,mapping = aes(x = GamePlayed, y = FinalScore, color = Contestant)) +
  geom_point() +
  geom_line() +
  ggtitle("Final Scores for All-Time Winning Jeopardy Contestants - Regular Season") +
  xlab("Game") +
  ylab("Final Score")
ggplot(data = game_scores_df_regular_season,mapping = aes(x = GamePlayed, y = FinalScore)) +
  geom_point() +
  geom_line() +
  ggtitle("Final Scores for All-Time Winning Jeopardy Contestants - Regular Season") +
  xlab("Game") +
  ylab("Final Score") +
  facet_wrap(~ Contestant, nrow = 5)
```

<Discuss skews due to Brad's winnings being pre-doubled and James' due to aggresive wagering. Move on to Coryat Score>

## Coryat Score

<Discuss what Coryat Score is, origin, and other manipulation done to data (i.e. Brad's doubling for regular season games), will plot max and average scores, also will exclude All Star games since that was three person game>

```{r coryatScores, echo=FALSE, warning = FALSE}
coryat_scores_df <- game_level_df %>%
  filter(TournamentName != "All-Star Games") %>%
  rowwise() %>%
  mutate(FinalScoreAdjusted = ifelse(GameId < 3966 && TournamentName != "Greatest of All Time", FinalScore*2, FinalScore),
         CoryatScoreAdjusted = ifelse(GameId < 3966 && TournamentName != "Greatest of All Time", CoryatScore*2, CoryatScore)) %>%
  select(Contestant, FinalScoreAdjusted, CoryatScoreAdjusted) %>%
  group_by(Contestant) %>%
  summarize(MaxFinalScore = max(FinalScoreAdjusted),
            AverageFinalScore = mean(FinalScoreAdjusted),
            MaxCoryatScore = max(CoryatScoreAdjusted),
            AverageCoryatScore = mean(CoryatScoreAdjusted))
coryat_scores_df <- coryat_scores_df %>%
  gather("MaxFinalScore", "AverageFinalScore", "MaxCoryatScore", "AverageCoryatScore", key = "Attribute", value = "Score")
ggplot(data = coryat_scores_df, mapping = aes(x = Contestant, y = Score, color = Attribute, size = Attribute)) +
  geom_point() +
  ggtitle("Coryat Scores versus Final Scores") +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_color_discrete(name = "Score Type",
                       labels = c("Average Coryat Score", "Average Final Score", "Max Coryat Score", "Max Final Score")) +
  scale_y_continuous(breaks = seq(0,140000,20000)) +
  scale_size_discrete(name = "Score Type",
                       labels = c("Average Coryat Score", "Average Final Score", "Max Coryat Score", "Max Final Score"))
  
```

